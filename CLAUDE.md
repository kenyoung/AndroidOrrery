# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Build Commands

```bash
./gradlew build                    # Full build
./gradlew assembleDebug            # Debug APK only
./gradlew assembleRelease          # Release APK only
./gradlew test                     # Unit tests
./gradlew connectedAndroidTest     # Instrumented tests (requires device/emulator)
./gradlew installDebug             # Install debug APK to connected device
```

## Project Overview

Android Orrery is an astronomical visualization app built entirely with Jetpack Compose. It displays planet positions, rise/set times, lunar phases, Jovian moon events, meteor showers, and other astronomical phenomena. The app is inspired by Sky & Telescope's "Sky Gazer's Almanac" but customized to the user's location and time.

**Package:** `com.kenyoung.orrery`
**Min SDK:** 26 | **Target SDK:** 36

## Architecture

### Single Activity + Compose Navigation

- `MainActivity.kt` is the only activity; all UI is Compose-based (no XML layouts)
- Navigation uses a `Screen` enum with 12 screens, selected via dropdown menu
- State is managed directly in composables using `mutableStateOf()` (no ViewModels)

### Screen Enum

```kotlin
enum class Screen {
    TRANSITS, ELEVATIONS, PHENOMENA, COMPASS, MOON_CALENDAR,
    JOVIAN_MOONS, JOVIAN_EVENTS, SCHEMATIC, SCALE, TIMES, ANALEMMA,
    METEOR_SHOWERS
}
```

### Three-Tier Calculation Layer

1. **EphemerisManager** (`EphemerisManager.kt`) - Singleton that loads binary ephemeris data from assets at startup. Interpolates RA/Dec, distances, and ecliptic coordinates for planets and Moon (6-hour resolution, 2021-2031).

2. **AstroEngine** (`AstroEngine.kt`) - Wrapper returning `BodyState` data class with complete position info. Uses ephemeris data when available, falls back to Keplerian math.

3. **AstroMath** (`AstroMath.kt`) - Raw mathematical functions: coordinate conversions (equatorial/ecliptic/cartesian), time calculations (sidereal, equation of time), rise/set algorithms, Kepler equation solver.

### Key Data Classes (in `AstroModels.kt`)

- `BodyState` - Complete position info for a celestial body (RA, Dec, distances, ecliptic coords)
- `PlanetElements` - Keplerian orbital elements for a planet
- `JovianMoonState` - Position and eclipse state for Galilean moons
- `AstroCache` - Pre-computed 16-month cache of rise/set/transit times

### Screen Files

Each screen is self-contained in its own file with embedded calculation logic:
- `TransitsScreen.kt` - Year-long transit calendar
- `PlanetElevationsScreen.kt` - 24-hour elevation graph
- `PlanetCompassScreen.kt` - Azimuth/altitude compass view
- `PlanetPhenomenaScreen.kt` - Conjunctions, oppositions, elongations
- `MoonCalendarScreen.kt` - Monthly lunar phase calendar
- `JovianMoonsScreen.kt` - Galilean moon positions
- `JovianEventsScreen.kt` - Jovian moon mutual events
- `OrreryScreens.kt` - Both schematic and to-scale orrery views
- `AnalemmaScreen.kt` - Equation of time figure-8 plot
- `MeteorShowerScreen.kt` - Annual meteor shower calendar
- `Times.kt` - JD, MJD, sidereal time display

## Ephemeris Data Pipeline

Binary ephemeris files in `app/src/main/assets/` are generated by Python scripts in `scripts/`:

1. `generatePlanetsEphemeris.py` - Fetches data from JPL Horizons API
2. `generateMoonEphemeris.py` - Generates lunar ephemeris
3. `convertEphemeris.py` - Converts CSV to binary format (little-endian doubles, stride of 6 per entry)

Data covers 2021-01-01 to 2031-01-01 at 6-hour resolution.

## Time and Location System

- All internal calculations use UT (Universal Time)
- User can toggle between phone GPS/time or manual entry
- Manual location uses degrees-minutes-seconds format
- Time animation system allows forward scrubbing at 1, 10, or 100 years per button press

## Rendering

Uses Compose `Canvas` with `drawIntoCanvas { canvas.nativeCanvas... }` for custom astronomical graphics. Gestural input via `pointerInput()` for pan/zoom on applicable screens.

Don't try to compile, build or run the app. I will do that in Android Studio.
